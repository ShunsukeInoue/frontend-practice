import json
import math

def to_obj(x):
    """Difyで来るHTTPレスポンスが str(JSON) でも dict でも受けられるようにする"""
    if isinstance(x, dict):
        return x
    if isinstance(x, str):
        x = x.strip()
        # たまに前後に余計な文字が付くことがあるので最低限ガード
        return json.loads(x)
    raise TypeError(f"Unsupported type: {type(x)}")

def mean(xs):
    xs = [v for v in xs if isinstance(v, (int, float))]
    return sum(xs) / len(xs) if xs else None

def extract_avg_logprob(resp: dict) -> float:
    choice = resp.get("choices", [{}])[0]
    lp = choice.get("logprobs") or {}

    # よくある形式: {"content":[{"token":"...", "logprob": -0.1}, ...]}
    if isinstance(lp, dict) and isinstance(lp.get("content"), list):
        vals = [t.get("logprob") for t in lp["content"] if isinstance(t, dict)]
        v = mean(vals)
        if v is not None:
            return v

    # 形式ゆれ吸収（あれば拾う）
    for key in ["token_logprobs", "logprobs", "tokenLogprobs"]:
        if isinstance(lp, dict) and isinstance(lp.get(key), list):
            v = mean(lp[key])
            if v is not None:
                return v

    raise ValueError("logprobs が見つからない/形式が想定外です。HTTPレスポンスを確認してください。")

def sigmoid(x: float) -> float:
    return 1.0 / (1.0 + math.exp(-x))

# ---- ここから実処理 ----
resp_withA = to_obj(withA)  # withA が str でも dict でもOK
resp_noA   = to_obj(noA)

avg_withA = extract_avg_logprob(resp_withA)
avg_noA   = extract_avg_logprob(resp_noA)

delta = avg_withA - avg_noA

k = 3.0  # 感度（まず3、弱ければ上げる）
score = sigmoid(k * delta)  # 0〜1

# 「関連なしは0寄りにしたい」ならこれに置き換えも可
# score = max(0.0, (score - 0.5) * 2.0)

result = {
    "answer_relevance": score,
    "delta": delta,
    "avg_withA": avg_withA,
    "avg_noA": avg_noA,
}
