import math

def mean(xs):
    xs = [x for x in xs if isinstance(x, (int, float))]
    return sum(xs) / len(xs) if xs else None

def extract_avg_logprob(resp: dict) -> float:
    """
    Azure chat/completions のレスポンスから、
    出力トークンの logprob を全部集めて平均を返す。
    形式差を吸収するために複数パターンを試す。
    """
    choice = resp.get("choices", [{}])[0]
    lp = choice.get("logprobs") or {}

    # パターンA: {"content":[{"token":"...", "logprob": -0.1}, ...]}
    if isinstance(lp, dict) and isinstance(lp.get("content"), list):
        vals = [t.get("logprob") for t in lp["content"] if isinstance(t, dict)]
        v = mean(vals)
        if v is not None:
            return v

    # パターンB: token_logprobs のような配列がある
    for key in ["token_logprobs", "logprobs", "tokenLogprobs"]:
        if isinstance(lp, dict) and isinstance(lp.get(key), list):
            v = mean(lp[key])
            if v is not None:
                return v

    raise ValueError("logprobs が期待した形式で見つかりません。HTTPノードのレスポンスを確認してください。")

def sigmoid(x: float) -> float:
    return 1.0 / (1.0 + math.exp(-x))

# ---- ここから実処理 ----
resp_withA = withA   # ← DifyでHTTP①の出力を withA に入れておく
resp_noA   = noA     # ← DifyでHTTP②の出力を noA に入れておく

avg_withA = extract_avg_logprob(resp_withA)
avg_noA   = extract_avg_logprob(resp_noA)

delta = avg_withA - avg_noA

k = 3.0  # 感度。まずは3でOK。強くしたければ5、弱くしたければ2
score = sigmoid(k * delta)

# もし「関連なしは0に寄せたい」なら、0.5基準をカットして下を0に潰す例
# score = max(0.0, (score - 0.5) * 2.0)  # 0.5→0, 1.0→1 に再スケール

result = {
    "answer_relevance": score,
    "delta": delta,
    "avg_withA": avg_withA,
    "avg_noA": avg_noA,
}
